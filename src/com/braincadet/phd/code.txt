//        int degree = 3;
//        float[] p = new float[tness.length];
//        for (int i = 0; i < tness.length; i++) {
//            tness[i] = (tness[i]-tnessmin)/(tnessmax-tnessmin); // min-max normalize [0,1], will be used in importance sampling, directional filtering
//            p[i] = (i==0)? (float) Math.pow(tness[0],degree) : p[i-1] + (float) Math.pow(tness[i], degree) ; // power to give more importance to those with high tness (todo: use cummulative weights)
//        }
//        int[][] samplexyz = sample(NOBJ_INIT, p, locationXYZ);

//        IJ.setAutoThreshold(itnesscopy, "Default dark stack");
//        Prefs.blackBackground = true;
//        IJ.run(itnesscopy, "Convert to Mask", "method=Default background=Dark black");

//        if (P>1) {
//            // FIX: binarizing 2d and 3d images in IJ does not work the same
//            // in a nutshell: if value 255 is needed in foreground in binarization
//            // 3d images background value is 255, foreground 0
//            // 2d images background value is 0,   foreground 255
//            // it's important for the skeletonization and location selection later on
//            IJ.run(itnesscopy, "Invert", "stack");
//        }

//        AutoThresholder at = new AutoThresholder();
//        int threshold = at.getThreshold(thmethod, gethist(itnesscopy, itnesscopy.getStack().getSize()>1));

//        for (int z = 1; z <= P; z++) { // layer count, zcoord is layer-1
//            float[] slc = (float[]) ip_tness.getStack().getPixels(z);
//            for (int x = 0; x < N; x++) {
//                for (int y = 0; y < M; y++) {
//                    int ii = (z-1)*(N*M)+y*N+x;
//                    tness[ii] = slc[y*N+x];
//
//                    if (tness[ii]<tnessmin) tnessmin = tness[ii];
//                    if (tness[ii]>tnessmax) tnessmax = tness[ii];
//                }
//            }
//        }

//                                                    ArrayList<Integer> lcstemp  =  new ArrayList<Integer>(lcs.size());
//                                                    ArrayList<Float> lcstempw =  new ArrayList<Float>(lcs_w.size());
//                                                    lcstemp.clear();  // lcstemp will hold subset of those that had not been covered with suppmap
//                                                    lcstempw.clear(); //
//                                                    for (int i = 0; i < lcs.size(); i++) {
////                                                        int xi = lcs.get(i)[0];
////                                                        int yi = lcs.get(i)[1];
////                                                        int zi = lcs.get(i)[2];
////                                                        int ii = zi*(N*M)+yi*N+xi;
//                                                        if (suppmap[lcs.get(i)]==0) {
//                                                            lcstemp.add(lcs.get(i)); // keep those that were not suppressed
//                                                            lcstempw.add(lcs_w.get(i));
//                                                        }
//                                                    }
//                                                        if (lcs.size()>0)
//                                                            IJ.log("keep " + IJ.d2s((lcstemp.size()*100f)/lcs.size(), 2) + "%");
                                                    // reassign back lcstemp -> lcs
//                                                    lcs.clear(); // assign them back to the lcs for the next epoch
//                                                    lcs_w.clear();
//                                                    for (int i = 0; i < lcstemp.size(); i++) {
//                                                        lcs.add(lcstemp.get(i));
//                                                        lcs_w.add(lcstempw.get(i));
//                                                    }
//                                                    lcstemp.clear();
//                                                    lcstempw.clear();

//                                                    if (savemidres) {
//                                                        // export the skeleton image
////                                                        int N, M, P, SZ;                        // stack dimensions (width, height, length, size)
//                                                        ImageStack isepch = new ImageStack(N, M); // allocate image stack that will be saved
//                                                        for (int i = 0; i < P; i++) {
//                                                            byte[] slice = new byte[N*M];
//                                                            isepch.addSlice(new ByteProcessor(N, M, slice));
//                                                        }
//                                                        // go through all the points and pinpoint them in the allocated stack
//                                                        for (int i = 0; i < lcs.size(); i++) {
//
//                                                            int x = lcs.get(i) % N;
//                                                            int zz = lcs.get(i) / (N*M);
//                                                            int y = lcs.get(i)/N - zz*M;
//
//                                                            byte[] slice = (byte[])isepch.getPixels(zz+1);
//                                                            slice[y*N+x] = (byte)255;
//
//                                                        }
//
//                                                        ImagePlus ipepch = new ImagePlus("locs,e=" + IJ.d2s(epochcnt, 0)+"", isepch);
//                                                        IJ.saveAs(ipepch, "Tiff", midresdir + File.separator + "locs,e=" + IJ.d2s(epochcnt, 0) + ".tif");
//
//                                                    }



//                                                IJ.run(itnesscopy, "Skeletonize", "stack");
//                                                if (savemidres) {
//                                                    IJ.saveAs(itnesscopy, "Tiff", midresdir + File.separator + "s.tif");
//                                                }

            for (int j = 0; j < mm.p.length; j++) {

                xj = xi + mm.p[j][0];
                yj = yi + mm.p[j][1];
                zj = zi + mm.p[j][2];
                ii = zj*(N*M)+yj*N+xj;

                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {
                    float localtness = (tnessmax-tnessmin>Float.MIN_VALUE)? ((tness[ii]-tnessmin)/(tnessmax-tnessmin)) : 0f;
                    localtness = (float) Math.exp(2*localtness);
                    summ += localtness;
                    mm.pcws[j] = localtness;
                }
                else {
                    float ltness = 0;
                    ltness = 1;
                    summ += ltness;
                }

            }









                        if (false&&first) {

                            int ip = mm.getdirection(-xp.vx, -xp.vy, -xp.vz);
                            Arrays.fill(mm.pcws, 0);

                            for (int j = 0; j < mm.p.length; j++) {

                                xj = xi + mm.p[j][0];
                                yj = yi + mm.p[j][1];
                                zj = zi + mm.p[j][2];
                                ii = zj*(N*M)+yj*N+xj;

                                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {// && suppmap[ii]==0
            //                        float localtness = (tnessmax-tnessmin>Float.MIN_VALUE)? ((tness[ii]-tnessmin)/(tnessmax-tnessmin)) : 0f;
                                    sc = 1;//mm.w[ip][j] * Math.exp(2*localtness);
                                }
                                else
                                    sc = 0;

                                mm.pcws[j] = (float) ((j==0)? sc : (sc+mm.pcws[j-1]));

                            }

                            if (mm.pcws[mm.pcws.length-1]>Float.MIN_VALUE) { // sample from the cummulative distribution

                                // *** sampling ni ***

                                // normalize

                                for (int j = 0; j < mm.pcws.length; j++) {
                                    mm.pcws[j] /= mm.pcws[mm.pcws.length-1];
                                }

                                float wmass = mm.pcws[mm.pcws.length-1];
                                float u1 = (wmass/ni)  * rndgen.nextFloat();

                                int s = 0;

                                ArrayList<X> xpick = new ArrayList<X>();

                                for (int j = 0; j < ni; j++) {
                                    float uj = u1 + j * (wmass/ni);
                                    while (uj>mm.pcws[s]) s++;

                                    xj = xi + mm.p[s][0];
                                    yj = yi + mm.p[s][1];
                                    zj = zi + mm.p[s][2];
                                    ii = zj*(N*M)+yj*N+xj;
                                    tnessval = tness[ii];

                                    // add to predicted particles if it is not suppressed voxel
                                    if (suppmap[ii]==0) {

                                        particle = new X(xj,yj,zj,   mm.u[s][0],mm.u[s][1],mm.u[s][2],    1,1, 99, tnessval);
                                        particle.tag = xp.tag;

                                        xpick.add(particle);

                                    }

                                }

                                // add once it is clear how many there are
                                for (int j = 0; j < xpick.size(); j++) {
                                    xpick.get(j).w = pS * xp.w * (1f/xpick.size());
                                    XPk.add(xpick.get(j));
                                    if (XPk_cws.size()==0)  XPk_cws.add(xpick.get(j).w);
                                    else                    XPk_cws.add(xpick.get(j).w + XPk_cws.get(XPk_cws.size()-1));
                                }

                            }

                        } // initpred

                                    // the distribution determined by p.d.f. that's multiplication of prior weights and the tness
                        //            for (int j = 0; j < mm.p.length; j++) { // go through the Stepper offsets defined with step and kappa
                        //                xj = xi + mm.p[j][0];
                        //                yj = yi + mm.p[j][1];
                        //                zj = zi + mm.p[j][2];
                        //                ii = zj*(N*M)+yj*N+xj;
                        //                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) { // && suppmap[ii]==0
                        //                    float localtness = (tnessmax-tnessmin>Float.MIN_VALUE)? ((tness[ii]-tnessmin)/(tnessmax-tnessmin)) : 0f;
                        //                    sc = mm.w[ip][j] * mm.pcws[j];
                        //                }
                        //                else
                        //                    sc = 0;
                        //                sc = 1;//mm.w[ip][j];// * mm.pcws[j];
                        //            }


                        //        int MIN_CNT = 1;
                        //        float MIN_TNESS = Float.MIN_VALUE;//(float) (0.01f*tnessinit);
                        //        for (int i = 0; i < Zk1.size(); i++) {
                        //            int x = Math.round(Zk1.get(i).x);
                        //            int y = Math.round(Zk1.get(i).y);
                        //            int z = Math.round(Zk1.get(i).z);
                        //            Zk1.get(i).tness = tness[z*(N*M)+y*(N)+x]; // set tness value (it was NaN)
                        //            if (Zk1.get(i).tness > MIN_TNESS && cnt1.get(i) >= MIN_CNT) { // it doesn't make sense to pick measurements below some level
                        //                Zk.add(new X(Zk1.get(i)));
                        //                Zk_cnt.add(cnt1.get(i));
                        //            }
                        //        }
                        //        log+="|Z|="+Zk.size()+", ";


                        //        IJ.log(" -- normalize");
                                // tubeness min-max normalize and store in an array for later and extract locations in a separate array
                        //        float tnessmin = Float.POSITIVE_INFINITY;
                        //        float tnessmax = Float.NEGATIVE_INFINITY;
                        //        tness = new float[SZ];
                        //        for (int i = 0; i < SZ; i++) {
                        //            if (tness[i]<tnessmin) tnessmin = tness[i];
                        //            if (tness[i]>tnessmax) tnessmax = tness[i];
                        //        }

                                                                                // random sample initial locations from locs using lcsw as importance function
                                                                                // pick sample based on tubeness, cws re-calculate before sampling
                        //                                                        ArrayList<Double> locscws = new ArrayList<Double>(locsw.size());
                        //                                                        locscws.clear();
                        //                                                        for (int i = 0; i < locsw.size(); i++) {
                        //                                                            if (i == 0)
                        //                                                                locscws.add((double) locsw.get(0));
                        //                                                            else
                        //                                                                locscws.add((double) locsw.get(i) + locscws.get(i - 1));
                        //                                                        }
                        //                                                        ArrayList<Integer> samps = importsamp(locscws, no[i01]);
                        //                                                        locscws.clear();
                        //                                                        ArrayList<int[]> locs1 = new ArrayList<int[]>(samps.size());
                        //                                                        for (int i = 0; i < samps.size(); i++) {
                        //                                                            int ii = locs.get(samps.get(i));
                        //                                                            int x = ii % N;
                        //                                                            int z = ii / (N * M);
                        //                                                            int y = ii / N - z * M;
                        //                                                            locs1.add(new int[]{x, y, z});
                        //                                                        }
                        //                                                        mtt.init(locs1, img, N, M, P, tness, suppmap);






                        //        for (int i = 0; i < seed_xyz.size(); i++) {
                        //            atloc.clear();
                        //            boolean isok = extractloc(img, N, M, P, seed_xyz.get(i), tness, atloc);
                        //            if (isok) {
                        //                for (int j = 0; j < atloc.size(); j++) {
                        //                    if (j!=0) {
                        //                        atloc.get(j).vx = atloc.get(0).vx;
                        //                        atloc.get(j).vy = atloc.get(0).vy;
                        //                        atloc.get(j).vz = atloc.get(0).vz;
                        //                    }
                        //                    // tags will be zero at the beginning so that they are not linked
                        //                    atloc.get(j).tag = 0;
                        //                    Xk.add(atloc.get(j));
                        //                }
                        //            }
                        //        }


                        //        if (verbose) IJ.log("npcles="+npcles);
                        //        int cnt = 0;
                        //        float wmin = Float.POSITIVE_INFINITY;
                        //        float wmax = Float.NEGATIVE_INFINITY;
                        //        for (int i = 0; i < XPk.size(); i++) {
                        //            if (Math.round(XPk.get(i).w*ro)>1) {
                        //                cnt++;
                        //            }
                        //            if (XPk.get(i).w<wmin) wmin = XPk.get(i).w;
                        //            if (XPk.get(i).w>wmax) wmax = XPk.get(i).w;
                        //        }
                        //        IJ.log(IJ.d2s((cnt/(float)XPk.size())*100,2) + "% samples wmin="+IJ.d2s(wmin,1)+", wmax="+IJ.d2s(wmax,1));
                        //        int Nres;
                        //        for (int i = 0; i < XPk.size(); i++) {
                        //            Nres = Math.round(XPk.get(i).w*ro);
                        //            if (Nres>1) {
                        //                for (int j = 0; j < Nres; j++) {}
                        //            }
                        //        }



                        //        int mintag = Integer.MAX_VALUE;
                        //        int maxtag = Integer.MIN_VALUE;
                        //        for (int i = 0; i < XPk.size(); i++) {
                        //            if (XPk.get(i).tag<mintag) mintag = XPk.get(i).tag;
                        //            if (XPk.get(i).tag>maxtag) maxtag = XPk.get(i).tag;
                        //        }
                        //        IJ.log("Y.size="+Y.size()+", maxtag="+(Y.size()-1)+"   --->   XPk.tag: " + mintag + " -- "+maxtag);


//        for (int i = 0; i < xgrouping.size(); i++) {
//            for (int j = 0; j < xgrouping.get(i).size(); j++) {
//                if (zp.get(xgrouping.get(i).get(j)).tag>=Yprev.size()) {
//                    IJ.log("$$ cluster "+i+" : index "+j + " no reference!!!");
//                }
//            }
//        }


//                else {
                    // those are the clusters that did not have enough counts to be considered as a cluster
                    // set that XPk particle to null and weight to 0
                    // it's important that they are not used later on in estimation (if it's not using the resampled values), resampling and update
                    // tricky to remove them from the x list now
//                    for (int k = 0; k < xgrouping1.size(); k++) {
//                        IJ.log("x["+xgrouping1.get(k)+"]=null");
//                        x.set(, null);
//                        x.get(xgrouping1.get(k)).w = 0; // so that it's not resampled
//                    }
//                }


            // calculate score for each cluster (max for all particles in that cluster)
//            int loc_max = Float.NEGATIVE_INFINITY;
//            int x = Math.round(xclust.get(desc_idx[ii]).x);
//            int y = Math.round(xclust.get(desc_idx[ii]).y);
//            int z = Math.round(xclust.get(desc_idx[ii]).z);
//            if (x>=0 && x<N && y>=0 && y<M && z>=0 && z<P) {
//                if (suppmap[z*(N*M)+y*(N)+x]==0) {
                    // add observation if it is not marked by the suppression map
//                    X xtt = new X(xclust.get(desc_idx[ii]));
//                    xtt.tness = tness[z*(N*M)+y*(N)+x];
//                    zout.add(xtt);
//                    zout_count.add(cnt.get(ii));
//                }
//            }
            // add tness value to z
//            int x = Math.round(xtt.x);
//            int y = Math.round(xtt.y);
//            int z = Math.round(xtt.z);


//        int cntt = 0;
//        for (int i = 0; i < XG.size(); i++)
//            for (int j = 0; j < XG.get(i).size(); j++)
//                cntt++;
//        IJ.log(cntt+"/"+XPk.size()+" ->  "+IJ.d2s(cntt/(float)XPk.size(),2));

//        if (Gk.size()==0) {
//            IJ.log("Gk.size()==0 ----> Xk won't be resampled");
//            return false; // _iter1() should stop iterok=false
//        }

//        mintag = Integer.MAX_VALUE;
//        maxtag = Integer.MIN_VALUE;
//        for (int i = 0; i < XPk.size(); i++) {
//            if (XPk.get(i).tag<mintag) mintag = XPk.get(i).tag;
//            if (XPk.get(i).tag>maxtag) maxtag = XPk.get(i).tag;
//        }
//        IJ.log("estimate() ----> XPk.tag  : "+mintag+" -- " + maxtag);

        // go through resampled Xk and append to suppmap[] so that those that will be used for prediction are added to the map
//        for (int i = 0; i < Xk.size(); i++) {
//
//            //*** suppression map filled using particles that make cluster tagged with newtag
//            int x1 = Math.round(Xk.get(i).x);
//            int y1 = Math.round(Xk.get(i).y);
//            int z1 = Math.round(Xk.get(i).z);
//            int tag1 = Xk.get(i).tag;
//            int ii1 = z1*(N*M)+y1*N+x1;
//
//            if (suppmap[ii1]==0) suppmap[ii1] = tag1;
//
//            // or fill out the neighbourhood
//            if (false) {
//                for (int k = 0; k < offxyz[R_supp].length; k++) {
//
//                    int xoff = x1 + offxyz[R_supp][k][0];
//                    int yoff = y1 + offxyz[R_supp][k][1];
//                    int zoff = z1 + offxyz[R_supp][k][2];
//
//                    if (xoff>=0 && xoff<N && yoff>=0 && yoff<M && zoff>=0 && zoff<P) {
//
//                        int ioff = zoff*(N*M)+yoff*N+xoff;
//
//                        if (suppmap[ioff]==0) suppmap[ioff] = tag1;
//                    }
//                }
//            }
//
//        }

//        mintag = Integer.MAX_VALUE;
//        maxtag = Integer.MIN_VALUE;
//        for (int i = 0; i < Xk.size(); i++) {
//            if (Xk.get(i).tag<mintag) mintag = Xk.get(i).tag;
//            if (Xk.get(i).tag>maxtag) maxtag = Xk.get(i).tag;
//        }
//        IJ.log("resample() ----> Xk.tag: "+mintag+" -- " + maxtag);




//            wmass = (float) mm._w_cws[ip][mm._sz-1];
//            u1 = (wmass/ni)  * rndgen.nextFloat();
//            s = 0;
//            xpick.clear();
//            for (int j = 0; j < ni; j++) {
//                float uj = u1 + j * (wmass/ni);
//                while (uj>mm._w_cws[ip][s] && s<mm._sz-1) s++;
//                xj = xi + mm._p[s][0]; // add s-th
//                yj = yi + mm._p[s][1];
//                zj = zi + mm._p[s][2];
//                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {
//                    ii = zj*(N*M)+yj*N+xj;
//                    tnessval = tness[ii];
//                    particle = new X(xj,yj,zj, mm._u[s][0],mm._u[s][1],mm._u[s][2], .66f, tnessval);
//                    particle.tag = xp.tag;
//                    xpick.add(particle);
//                }
//            }

    /*
    public boolean iter1(int N, int M, int P, float[] tness, int[] suppmap) {

        if (verbose) IJ.log("|X|="+Xk.size());

        /*/
/*** prediction ***//*
/
        int xi, yi, zi, xj, yj, zj, ii;
        float tnessval;
        X particle;

        XPk.clear();
        XPk.trimToSize();
        XPk_cws.clear();

        for (int i = 0; i < Xk.size(); i++) {

            X xp = Xk.get(i);

            xi = Math.round(xp.x);
            yi = Math.round(xp.y);
            zi = Math.round(xp.z);

            // it's necessary to have local min/max so that values are locally optimal
            float tmin = Float.POSITIVE_INFINITY;
            float tmax = Float.NEGATIVE_INFINITY;

            Arrays.fill(mm.pcws, 0);
            for (int j = 0; j < mm.pcws.length; j++) {

                xj = xi + mm.p[j][0];
                yj = yi + mm.p[j][1];
                zj = zi + mm.p[j][2];
                ii = zj*(N*M)+yj*N+xj;

                mm.pcws[j] = ((xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P)? tness[ii] : 0); //  && suppmap[ii]==0

                if (mm.pcws[j]<tmin) tmin = mm.pcws[j];
                if (mm.pcws[j]>tmax) tmax = mm.pcws[j];

            }

            int ip = mm.getdirection(xp.vx, xp.vy, xp.vz); // direction

            for (int j = 0; j < mm.pcws.length; j++) {

                mm.pcws[j] = (tmax-tmin> Float.MIN_VALUE)? ((mm.pcws[j]-tmin)/(tmax-tmin)) : 0 ;
                mm.pcws[j] = (float) (Math.pow(mm.pcws[j],weight_deg) * mm.w[ip][j]); //
                mm.pcws[j] = ((j==0)? mm.pcws[j] : (mm.pcws[j]+mm.pcws[j-1]));

            }

            if (mm.pcws[mm.pcws.length-1]<=Float.MIN_VALUE) continue;

            float wmass = mm.pcws[mm.pcws.length-1];
            float u1 = (wmass/ni)  * rndgen.nextFloat();

            int s = 0;

            ArrayList<X> xpick = new ArrayList<X>();

            for (int j = 0; j < ni; j++) {

                float uj = u1 + j * (wmass/ni);

                while (uj>mm.pcws[s] & s<mm.pcws.length-1) s++;

                // add s-th
                xj = xi + mm.p[s][0];
                yj = yi + mm.p[s][1];
                zj = zi + mm.p[s][2];

                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {

                    ii = zj*(N*M)+yj*N+xj;

                    tnessval = tness[ii];

                    if (suppmap[ii]==0) {
                        particle = new X(xj,yj,zj,   mm.u[s][0],mm.u[s][1],mm.u[s][2], 99, tnessval);
                        particle.tag = xp.tag;
                        xpick.add(particle);
                    }
                    else {
                        IJ.log("wanted to pick one with suppmapp>0");
                    }

                }

            }

            // add once it is clear how many there are
            for (int j = 0; j < xpick.size(); j++) {
                xpick.get(j).w = pS * xp.w * (1f/xpick.size());
                XPk.add(xpick.get(j));
                if (XPk_cws.size()==0)  XPk_cws.add(xpick.get(j).w);
                else                    XPk_cws.add(xpick.get(j).w + XPk_cws.get(XPk_cws.size()-1));
            }

        } // go through Xk PHD particles

        if (verbose) IJ.log("|XPk|= "+XPk.size());

        if (XPk.size()==0) {
            IJ.log("XPk.size()==0");
            return false;
        }

        /*/
/** measure **//*
/
        Zk.clear();
        Zk.trimToSize();
        Zk_cnt.clear();

//        measure(XPk, kernel_radius, N, M, P, tness, Zk, Zk_cnt, null);//suppmap
        measure(XPk, kernel_radius, Y, N, M, P, tness, Zk);

        if (verbose) IJ.log("|Z|="+Zk.size());

        if (Zk.size()==0) {
            IJ.log("Zk.size()==0");
            return false;
        }

        /*/
/** update **//*
/
        XPk_cws = update(XPk, Zk); // updated weights will be added to cws output

        phdmass = XPk_cws.get(XPk_cws.size()-1);
        if (verbose) IJ.log("PHD="  +IJ.d2s(phdmass,2));

        if (Math.round(phdmass)<1) {
            IJ.log("Math.round(phdmass)<1");
            return false;
        }

        if (Math.round(phdmass)>OBJECT_LIMIT) {
            IJ.log("LIMIT: Math.round(phdmass)>" + OBJECT_LIMIT);
            phdmass = OBJECT_LIMIT;
        }

        int prevYsize = Y.size();
        estimate(XPk, kernel_radius, suppmap, R_supp, N, M, P, Y); // final estimates
        if (verbose) IJ.log("|Y|=" + (Y.size()-prevYsize));

        npcles = Math.round(phdmass)*ro;
        if (verbose) IJ.log("npcles="+npcles);
        resample(XPk, XPk_cws, npcles, Xk);

        return true;

    }

    */
    /*

    public boolean iter0(int N, int M, int P, float[] tness, int[] suppmap) {

        if (verbose) IJ.log("|X|="+Xk.size());
        /*//*** prediction ***//*/
        int xi, yi, zi, xj, yj, zj, ii;
        float tnessval;
        X particle;

        XPk.clear();
        XPk.trimToSize();
        XPk_cws.clear();

        for (int i = 0; i < Xk.size(); i++) {

            X xp = Xk.get(i);

            xi = Math.round(xp.x);
            yi = Math.round(xp.y);
            zi = Math.round(xp.z);

            // it's necessary to have local min/max so that values are locally optimal
            float tmin = Float.POSITIVE_INFINITY;
            float tmax = Float.NEGATIVE_INFINITY;

            Arrays.fill(mm.pcws, 0);
            for (int j = 0; j < mm.pcws.length; j++) {

                xj = xi + mm.p[j][0];
                yj = yi + mm.p[j][1];
                zj = zi + mm.p[j][2];
                ii = zj*(N*M)+yj*N+xj;

                mm.pcws[j] = (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P)? tness[ii] : 0;

                if (mm.pcws[j]<tmin) tmin = mm.pcws[j];
                if (mm.pcws[j]>tmax) tmax = mm.pcws[j];

            }

            for (int j = 0; j < mm.pcws.length; j++) {

                mm.pcws[j] = (tmax-tmin> Float.MIN_VALUE)? ((mm.pcws[j]-tmin)/(tmax-tmin)) : 0 ;
                mm.pcws[j] = (float) (Math.pow(mm.pcws[j],weight_deg) * 1f); // mm.w0[j]
                mm.pcws[j] = ((j==0)? mm.pcws[j] : (mm.pcws[j]+mm.pcws[j-1]));

            }

            if (mm.pcws[mm.pcws.length-1]<=Float.MIN_VALUE) continue;

            float wmass = mm.pcws[mm.pcws.length-1];
            float u1 = (wmass/ni)  * rndgen.nextFloat();

            int s = 0;

            ArrayList<X> xpick = new ArrayList<X>();

            for (int j = 0; j < ni; j++) {

                float uj = u1 + j * (wmass/ni);

                while (uj>mm.pcws[s] && s<=mm.pcws.length-1) s++;

                // add s-th
                xj = xi + mm.p[s][0];
                yj = yi + mm.p[s][1];
                zj = zi + mm.p[s][2];

                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {

                    ii = zj*(N*M)+yj*N+xj;

                    tnessval = tness[ii];

                    if (suppmap[ii]==0) { // finally select those that were not suppressed
                        particle = new X(xj,yj,zj,   mm.u[s][0],mm.u[s][1],mm.u[s][2],    99, tnessval);// 1,1,
                        particle.tag = xp.tag;
                        xpick.add(particle);
                    }
//                    else {
//                        IJ.log("wanted to pick one with suppmapp>0");
//                    }

                }

            }

            // add once it is clear how many there are
            for (int j = 0; j < xpick.size(); j++) {
                xpick.get(j).w = pS * xp.w * (1f/xpick.size());
                XPk.add(xpick.get(j));
                if (XPk_cws.size()==0)  XPk_cws.add(xpick.get(j).w);
                else                    XPk_cws.add(xpick.get(j).w + XPk_cws.get(XPk_cws.size()-1));
            }

        } // go through Xk PHD particles

        if (verbose) IJ.log("|XPk|= "+XPk.size());

        if (XPk.size()==0) {
            IJ.log("XPk.size()==0");
            return false;
        }

        /*//** measure **//*/
        Zk.clear();
        Zk.trimToSize();
        Zk_cnt.clear();

//        measure(XPk, kernel_radius, N, M, P, tness, Zk, Zk_cnt, null);//suppmap
        measure(XPk, kernel_radius, Y, N, M, P, tness, Zk);

        if (verbose) IJ.log("|Z|="+Zk.size());

        if (Zk.size()==0) {
            IJ.log("Zk.size()==0");
            return false;
        }

        /*//** update **//*/
        XPk_cws = update(XPk, Zk); // updated weights will be added to cws output

        phdmass = XPk_cws.get(XPk_cws.size()-1);
        if (verbose) IJ.log("PHD="  +IJ.d2s(phdmass,2));

        if (Math.round(phdmass)<1) {
            IJ.log("Math.round(phdmass)<1");
            return false;
        }

        if (Math.round(phdmass)>OBJECT_LIMIT) {
            IJ.log("LIMIT: Math.round(phdmass)>" + OBJECT_LIMIT);
            phdmass = OBJECT_LIMIT;
        }

        int prevYsize = Y.size();
        estimate(XPk, kernel_radius, suppmap, R_supp, N, M, P, Y); // final estimates
        if (verbose) IJ.log("|Y|=" + (Y.size()-prevYsize));

        npcles = Math.round(phdmass)*ro;
        if (verbose) IJ.log("npcles="+npcles);
        resample(XPk, XPk_cws, npcles, Xk);

        return true;

    }
    */
    /*
    public boolean _iter0(int N, int M, int P, float[] tness, int[] suppmap) {

        String eventlog = "|X|="+ Xk.size() +" ";

        /*//*** prediction ***//*/
        int xi, yi, zi, xj, yj, zj, ii;
        float tnessval;
        X particle;

        XPk.clear();
        XPk.trimToSize();
        XPk_cws.clear();

        for (int i = 0; i < Xk.size(); i++) {

            X xp = Xk.get(i);

            xi = Math.round(xp.x);
            yi = Math.round(xp.y);
            zi = Math.round(xp.z);

            // it's necessary to have local min/max so that values are locally optimal
            float tmin = Float.POSITIVE_INFINITY;
            float tmax = Float.NEGATIVE_INFINITY;

            Arrays.fill(mm._pcws, 0);

            for (int j = 0; j < mm._pcws.length; j++) {

                xj = xi + mm._p[j][0];
                yj = yi + mm._p[j][1];
                zj = zi + mm._p[j][2];
                ii = zj*(N*M)+yj*N+xj;

                mm._pcws[j] = (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P)? tness[ii] : 0;

                if (mm._pcws[j]<tmin) tmin = mm._pcws[j];
                if (mm._pcws[j]>tmax) tmax = mm._pcws[j];

            }

            for (int j = 0; j < mm._pcws.length; j++) {

                mm._pcws[j] = (tmax-tmin> Float.MIN_VALUE)? ((mm._pcws[j]-tmin)/(tmax-tmin)) : 0 ;
                mm._pcws[j] = (float) (Math.pow(mm._pcws[j],weight_deg) * mm._w0[j]);
                mm._pcws[j] = (j==0)? mm._pcws[j] : (mm._pcws[j]+mm._pcws[j-1]);

            }

            if (mm._pcws[mm._pcws.length-1]<=Float.MIN_VALUE) {IJ.log("Xk["+i+"] had wmass "+mm._pcws[mm._pcws.length-1]); continue;}

            float wmass = mm._pcws[mm._pcws.length-1];
            float u1 = (wmass/ni)  * rndgen.nextFloat();

            int s = 0;

            ArrayList<X> xpick = new ArrayList<X>();

            for (int j = 0; j < ni; j++) {

                float uj = u1 + j * (wmass/ni);

                while (uj>mm._pcws[s] && s<mm._pcws.length-1) s++;

                // add s-th
                xj = xi + mm._p[s][0];
                yj = yi + mm._p[s][1];
                zj = zi + mm._p[s][2];

                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {

                    ii = zj*(N*M)+yj*N+xj;

                    tnessval = tness[ii];
                    // finally select those that were not suppressed (that don't overlap with previous particle trace)
                    if (suppmap[ii]==0) {
                        particle = new X(
                                xj,yj,zj,
                                mm._u[s][0],mm._u[s][1],mm._u[s][2],
                                99, tnessval);
                        particle.tag = xp.tag;
                        xpick.add(particle);
                    }

                }

            }

            // add once it is clear how many there are
            for (int j = 0; j < xpick.size(); j++) {
                xpick.get(j).w = pS * xp.w * (1f/xpick.size());
                XPk.add(xpick.get(j));
                if (XPk_cws.size()==0)  XPk_cws.add(xpick.get(j).w);
                else                    XPk_cws.add(xpick.get(j).w + XPk_cws.get(XPk_cws.size()-1));
            }

        } // go through Xk PHD particles

        eventlog += "|XPk|= "+XPk.size()+" ";

        if (XPk.size()==0) {
            IJ.log("XPk.size()==0");
            return false;
        }

        /*//** measure **//*/
        Zk.clear();
        Zk.trimToSize();
        Zk_cnt.clear();

//        measure(XPk, kernel_radius, N, M, P, tness, Zk, Zk_cnt, null);//suppmap
        measure(XPk, kernel_radius, Y, N, M, P, tness, Zk);

        eventlog += "|Z|=" + Zk.size() + " ";

        if (Zk.size()==0) {
            IJ.log("Zk.size()==0");
            return false;
        }

        /*//** update **//*/
        XPk_cws = update(XPk, Zk); // updated weights will be added to cws output

        phdmass = XPk_cws.get(XPk_cws.size()-1);

        eventlog += "PHD="  +IJ.d2s(phdmass,2) + " ";

        if (Math.round(phdmass)<1) {
            IJ.log("Math.round(phdmass)<1");
            return false;
        }

        if (Math.round(phdmass)>OBJECT_LIMIT) {
            IJ.log("LIMIT: Math.round(phdmass)>" + OBJECT_LIMIT);
            phdmass = OBJECT_LIMIT;
        }

        int prevYsize = Y.size();
        estimate(XPk,kernel_radius,suppmap,R_supp,N,M,P,Y);

        eventlog += "|Y|=" + (Y.size()-prevYsize)+" ";

        npcles = Math.round(phdmass)*ro;

        resample(XPk, XPk_cws, npcles, Xk);

        if (verbose) IJ.log(eventlog);

        return true;

    }
    */



    //    private void exportXYZSig(ArrayList<X> Xlist, String outdir, String swcname, int type) {
    //
    //        // exports only locations into swc format for visualization - the rest of the Xk instance is ignored
    //        if (outdir==null || swcname==null) return;
    //
    //        String outfile = outdir + File.separator + swcname + ".swc";
    //
    //        Tools.cleanfile(outfile);
    //
    //        try {
    //            PrintWriter logWriter = new PrintWriter(new BufferedWriter(new FileWriter(outfile, true)));
    //
    //            logWriter.println("#Xk,Yk,Z,Sig");
    //
    //            for (int i = 0; i < Xlist.size(); i++) {
    //                logWriter.println((i+1) + " " + type + " " +
    //                        IJ.d2s(Xlist.get(i).x, 4) + " " +
    //                        IJ.d2s(Xlist.get(i).y, 4) + " " +
    //                        IJ.d2s(Xlist.get(i).z, 4) + " " +
    //                        Xlist.get(i).sig + " " + -1);
    //            }
    //
    //            logWriter.close();
    //
    //        } catch (IOException e) {}
    //
    //    }
