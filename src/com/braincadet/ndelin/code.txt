//        int degree = 3;
//        float[] p = new float[tness.length];
//        for (int i = 0; i < tness.length; i++) {
//            tness[i] = (tness[i]-tnessmin)/(tnessmax-tnessmin); // min-max normalize [0,1], will be used in importance sampling, directional filtering
//            p[i] = (i==0)? (float) Math.pow(tness[0],degree) : p[i-1] + (float) Math.pow(tness[i], degree) ; // power to give more importance to those with high tness (todo: use cummulative weights)
//        }
//        int[][] samplexyz = sample(NOBJ_INIT, p, locationXYZ);

//        IJ.setAutoThreshold(itnesscopy, "Default dark stack");
//        Prefs.blackBackground = true;
//        IJ.run(itnesscopy, "Convert to Mask", "method=Default background=Dark black");

//        if (P>1) {
//            // FIX: binarizing 2d and 3d images in IJ does not work the same
//            // in a nutshell: if value 255 is needed in foreground in binarization
//            // 3d images background value is 255, foreground 0
//            // 2d images background value is 0,   foreground 255
//            // it's important for the skeletonization and location selection later on
//            IJ.run(itnesscopy, "Invert", "stack");
//        }

//        AutoThresholder at = new AutoThresholder();
//        int threshold = at.getThreshold(thmethod, gethist(itnesscopy, itnesscopy.getStack().getSize()>1));

//        for (int z = 1; z <= P; z++) { // layer count, zcoord is layer-1
//            float[] slc = (float[]) ip_tness.getStack().getPixels(z);
//            for (int x = 0; x < N; x++) {
//                for (int y = 0; y < M; y++) {
//                    int ii = (z-1)*(N*M)+y*N+x;
//                    tness[ii] = slc[y*N+x];
//
//                    if (tness[ii]<tnessmin) tnessmin = tness[ii];
//                    if (tness[ii]>tnessmax) tnessmax = tness[ii];
//                }
//            }
//        }

//                                                    ArrayList<Integer> lcstemp  =  new ArrayList<Integer>(lcs.size());
//                                                    ArrayList<Float> lcstempw =  new ArrayList<Float>(lcs_w.size());
//                                                    lcstemp.clear();  // lcstemp will hold subset of those that had not been covered with suppmap
//                                                    lcstempw.clear(); //
//                                                    for (int i = 0; i < lcs.size(); i++) {
////                                                        int xi = lcs.get(i)[0];
////                                                        int yi = lcs.get(i)[1];
////                                                        int zi = lcs.get(i)[2];
////                                                        int ii = zi*(N*M)+yi*N+xi;
//                                                        if (suppmap[lcs.get(i)]==0) {
//                                                            lcstemp.add(lcs.get(i)); // keep those that were not suppressed
//                                                            lcstempw.add(lcs_w.get(i));
//                                                        }
//                                                    }
//                                                        if (lcs.size()>0)
//                                                            IJ.log("keep " + IJ.d2s((lcstemp.size()*100f)/lcs.size(), 2) + "%");
                                                    // reassign back lcstemp -> lcs
//                                                    lcs.clear(); // assign them back to the lcs for the next epoch
//                                                    lcs_w.clear();
//                                                    for (int i = 0; i < lcstemp.size(); i++) {
//                                                        lcs.add(lcstemp.get(i));
//                                                        lcs_w.add(lcstempw.get(i));
//                                                    }
//                                                    lcstemp.clear();
//                                                    lcstempw.clear();

//                                                    if (savemidres) {
//                                                        // export the skeleton image
////                                                        int N, M, P, SZ;                        // stack dimensions (width, height, length, size)
//                                                        ImageStack isepch = new ImageStack(N, M); // allocate image stack that will be saved
//                                                        for (int i = 0; i < P; i++) {
//                                                            byte[] slice = new byte[N*M];
//                                                            isepch.addSlice(new ByteProcessor(N, M, slice));
//                                                        }
//                                                        // go through all the points and pinpoint them in the allocated stack
//                                                        for (int i = 0; i < lcs.size(); i++) {
//
//                                                            int x = lcs.get(i) % N;
//                                                            int zz = lcs.get(i) / (N*M);
//                                                            int y = lcs.get(i)/N - zz*M;
//
//                                                            byte[] slice = (byte[])isepch.getPixels(zz+1);
//                                                            slice[y*N+x] = (byte)255;
//
//                                                        }
//
//                                                        ImagePlus ipepch = new ImagePlus("locs,e=" + IJ.d2s(epochcnt, 0)+"", isepch);
//                                                        IJ.saveAs(ipepch, "Tiff", midresdir + File.separator + "locs,e=" + IJ.d2s(epochcnt, 0) + ".tif");
//
//                                                    }



//                                                IJ.run(itnesscopy, "Skeletonize", "stack");
//                                                if (savemidres) {
//                                                    IJ.saveAs(itnesscopy, "Tiff", midresdir + File.separator + "s.tif");
//                                                }

            for (int j = 0; j < mm.p.length; j++) {

                xj = xi + mm.p[j][0];
                yj = yi + mm.p[j][1];
                zj = zi + mm.p[j][2];
                ii = zj*(N*M)+yj*N+xj;

                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {
                    float localtness = (tnessmax-tnessmin>Float.MIN_VALUE)? ((tness[ii]-tnessmin)/(tnessmax-tnessmin)) : 0f;
                    localtness = (float) Math.exp(2*localtness);
                    summ += localtness;
                    mm.pcws[j] = localtness;
                }
                else {
                    float ltness = 0;
                    ltness = 1;
                    summ += ltness;
                }

            }









                        if (false&&first) {

                            int ip = mm.getdirection(-xp.vx, -xp.vy, -xp.vz);
                            Arrays.fill(mm.pcws, 0);

                            for (int j = 0; j < mm.p.length; j++) {

                                xj = xi + mm.p[j][0];
                                yj = yi + mm.p[j][1];
                                zj = zi + mm.p[j][2];
                                ii = zj*(N*M)+yj*N+xj;

                                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) {// && suppmap[ii]==0
            //                        float localtness = (tnessmax-tnessmin>Float.MIN_VALUE)? ((tness[ii]-tnessmin)/(tnessmax-tnessmin)) : 0f;
                                    sc = 1;//mm.w[ip][j] * Math.exp(2*localtness);
                                }
                                else
                                    sc = 0;

                                mm.pcws[j] = (float) ((j==0)? sc : (sc+mm.pcws[j-1]));

                            }

                            if (mm.pcws[mm.pcws.length-1]>Float.MIN_VALUE) { // sample from the cummulative distribution

                                // *** sampling ni ***

                                // normalize

                                for (int j = 0; j < mm.pcws.length; j++) {
                                    mm.pcws[j] /= mm.pcws[mm.pcws.length-1];
                                }

                                float wmass = mm.pcws[mm.pcws.length-1];
                                float u1 = (wmass/ni)  * rndgen.nextFloat();

                                int s = 0;

                                ArrayList<X> xpick = new ArrayList<X>();

                                for (int j = 0; j < ni; j++) {
                                    float uj = u1 + j * (wmass/ni);
                                    while (uj>mm.pcws[s]) s++;

                                    xj = xi + mm.p[s][0];
                                    yj = yi + mm.p[s][1];
                                    zj = zi + mm.p[s][2];
                                    ii = zj*(N*M)+yj*N+xj;
                                    tnessval = tness[ii];

                                    // add to predicted particles if it is not suppressed voxel
                                    if (suppmap[ii]==0) {

                                        particle = new X(xj,yj,zj,   mm.u[s][0],mm.u[s][1],mm.u[s][2],    1,1, 99, tnessval);
                                        particle.tag = xp.tag;

                                        xpick.add(particle);

                                    }

                                }

                                // add once it is clear how many there are
                                for (int j = 0; j < xpick.size(); j++) {
                                    xpick.get(j).w = pS * xp.w * (1f/xpick.size());
                                    XPk.add(xpick.get(j));
                                    if (XPk_cws.size()==0)  XPk_cws.add(xpick.get(j).w);
                                    else                    XPk_cws.add(xpick.get(j).w + XPk_cws.get(XPk_cws.size()-1));
                                }

                            }

                        } // initpred

                                    // the distribution determined by p.d.f. that's multiplication of prior weights and the tness
                        //            for (int j = 0; j < mm.p.length; j++) { // go through the Stepper offsets defined with step and kappa
                        //                xj = xi + mm.p[j][0];
                        //                yj = yi + mm.p[j][1];
                        //                zj = zi + mm.p[j][2];
                        //                ii = zj*(N*M)+yj*N+xj;
                        //                if (xj>=0 && xj<N && yj>=0 && yj<M && zj>=0 && zj<P) { // && suppmap[ii]==0
                        //                    float localtness = (tnessmax-tnessmin>Float.MIN_VALUE)? ((tness[ii]-tnessmin)/(tnessmax-tnessmin)) : 0f;
                        //                    sc = mm.w[ip][j] * mm.pcws[j];
                        //                }
                        //                else
                        //                    sc = 0;
                        //                sc = 1;//mm.w[ip][j];// * mm.pcws[j];
                        //            }


                        //        int MIN_CNT = 1;
                        //        float MIN_TNESS = Float.MIN_VALUE;//(float) (0.01f*tnessinit);
                        //        for (int i = 0; i < Zk1.size(); i++) {
                        //            int x = Math.round(Zk1.get(i).x);
                        //            int y = Math.round(Zk1.get(i).y);
                        //            int z = Math.round(Zk1.get(i).z);
                        //            Zk1.get(i).tness = tness[z*(N*M)+y*(N)+x]; // set tness value (it was NaN)
                        //            if (Zk1.get(i).tness > MIN_TNESS && cnt1.get(i) >= MIN_CNT) { // it doesn't make sense to pick measurements below some level
                        //                Zk.add(new X(Zk1.get(i)));
                        //                Zk_cnt.add(cnt1.get(i));
                        //            }
                        //        }
                        //        log+="|Z|="+Zk.size()+", ";


                        //        IJ.log(" -- normalize");
                                // tubeness min-max normalize and store in an array for later and extract locations in a separate array
                        //        float tnessmin = Float.POSITIVE_INFINITY;
                        //        float tnessmax = Float.NEGATIVE_INFINITY;
                        //        tness = new float[SZ];
                        //        for (int i = 0; i < SZ; i++) {
                        //            if (tness[i]<tnessmin) tnessmin = tness[i];
                        //            if (tness[i]>tnessmax) tnessmax = tness[i];
                        //        }

                                                                                // random sample initial locations from locs using lcsw as importance function
                                                                                // pick sample based on tubeness, cws re-calculate before sampling
                        //                                                        ArrayList<Double> locscws = new ArrayList<Double>(locsw.size());
                        //                                                        locscws.clear();
                        //                                                        for (int i = 0; i < locsw.size(); i++) {
                        //                                                            if (i == 0)
                        //                                                                locscws.add((double) locsw.get(0));
                        //                                                            else
                        //                                                                locscws.add((double) locsw.get(i) + locscws.get(i - 1));
                        //                                                        }
                        //                                                        ArrayList<Integer> samps = importsamp(locscws, no[i01]);
                        //                                                        locscws.clear();
                        //                                                        ArrayList<int[]> locs1 = new ArrayList<int[]>(samps.size());
                        //                                                        for (int i = 0; i < samps.size(); i++) {
                        //                                                            int ii = locs.get(samps.get(i));
                        //                                                            int x = ii % N;
                        //                                                            int z = ii / (N * M);
                        //                                                            int y = ii / N - z * M;
                        //                                                            locs1.add(new int[]{x, y, z});
                        //                                                        }
                        //                                                        mtt.init(locs1, img, N, M, P, tness, suppmap);






                        //        for (int i = 0; i < seed_xyz.size(); i++) {
                        //            atloc.clear();
                        //            boolean isok = extractloc(img, N, M, P, seed_xyz.get(i), tness, atloc);
                        //            if (isok) {
                        //                for (int j = 0; j < atloc.size(); j++) {
                        //                    if (j!=0) {
                        //                        atloc.get(j).vx = atloc.get(0).vx;
                        //                        atloc.get(j).vy = atloc.get(0).vy;
                        //                        atloc.get(j).vz = atloc.get(0).vz;
                        //                    }
                        //                    // tags will be zero at the beginning so that they are not linked
                        //                    atloc.get(j).tag = 0;
                        //                    Xk.add(atloc.get(j));
                        //                }
                        //            }
                        //        }


                        //        if (verbose) IJ.log("npcles="+npcles);
                        //        int cnt = 0;
                        //        float wmin = Float.POSITIVE_INFINITY;
                        //        float wmax = Float.NEGATIVE_INFINITY;
                        //        for (int i = 0; i < XPk.size(); i++) {
                        //            if (Math.round(XPk.get(i).w*ro)>1) {
                        //                cnt++;
                        //            }
                        //            if (XPk.get(i).w<wmin) wmin = XPk.get(i).w;
                        //            if (XPk.get(i).w>wmax) wmax = XPk.get(i).w;
                        //        }
                        //        IJ.log(IJ.d2s((cnt/(float)XPk.size())*100,2) + "% samples wmin="+IJ.d2s(wmin,1)+", wmax="+IJ.d2s(wmax,1));
                        //        int Nres;
                        //        for (int i = 0; i < XPk.size(); i++) {
                        //            Nres = Math.round(XPk.get(i).w*ro);
                        //            if (Nres>1) {
                        //                for (int j = 0; j < Nres; j++) {}
                        //            }
                        //        }